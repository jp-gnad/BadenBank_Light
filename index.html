<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Qualifikationslisten Deutschlanpokal 2025 - Prototyp </title>
<style>
body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    padding: 20px;
}
table {
    border-collapse: collapse;
    width: 100%;
    margin-bottom: 10px;
    font-size: 0.8em;
}

/* horizontales Scrollen ermöglichen */
.table-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    width: 100%;
}

}

/* Standard-Zellen */
th, td {
    border: 1px solid #ddd;
    padding: 8px;
    word-wrap: break-word;
}

/* Tabellenkopf */
thead th {
    background: #f4f4f4;
    text-align: center;
}

/* Zeilenüberschriften */
th[scope="row"] {
    font-weight: 600;
    background: #fafafa;
    text-align: left;
}

td {
    text-align: center;
}

caption {
    font-weight: 700;
    margin-bottom: 8px;
}

.button-container {
    text-align: right;
    margin-bottom: 20px;
}

.button-container button {
    padding: 5px 10px;
    margin-left: 5px;
}

/* Zusatz: Ab 600px wieder table-layout: fixed aktivieren */
@media screen and (max-width: 600px) {
    /* scrollbarer Container */
    .table-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* sanftes Scrollen auf iOS */
    }

    /* Tabelle selbst */
    *.table-container table {
        table-layout: fixed;
        min-width: 1200px; /* breiter als Bildschirm */
        width: 100%;
    }

	/* Tabelle und Spaltenbreite für Handys anpassen */
}


</style>
</head>
<body>
<h1>Quallilisten Deutschlanpokal 2025 - Prototyp</h1>
<h2>Männer</h2>
<div id="male-table"></div>
<div class="button-container">
    <button id="male-prev">Zurück</button>
    <button id="male-next">Weiter</button>
</div>
<h2>Frauen</h2>
<div id="female-table"></div>
<div class="button-container">
    <button id="female-prev">Zurück</button>
    <button id="female-next">Weiter</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
const EXCEL_URL = "https://raw.githubusercontent.com/jp-gnad/BadenBank_Light/main/test.xlsx";
const RECORDS_URL = "https://raw.githubusercontent.com/jp-gnad/BadenBank_Light/main/records.xlsx";
const PAGE_SIZE = 8;
const cutoffDate = new Date(2024, 10, 15); // Monate 0-basiert: 10 = November
// --- Abgesagte Namen ---
// Einfach hier die Namen reinschreiben (müssen genau so wie in den Daten stehen)
const canceledNames = ["Bocksnick, Andreas", "Landes, Marlene", "Blonski, Regina"]

function isCanceled(name) {
    return canceledNames.includes((name || "").trim());
}

let malePage = 0;
let femalePage = 0;
let maleData = [];
let femaleData = [];
let headers = [];
let records = {};

class CalculatorDiscipline {
    constructor(time, record){
        this.time = time;
        this.record = record;
    }
    getPoints(){
        if(this.time <= 0.005) return 0;
        const ratio = this.time / this.record;
        if(ratio >= 5) return 0;
        if(ratio >= 2) return Math.round((2000/3 - 400/3*ratio)*100)/100;
        return Math.round((467*ratio*ratio - 2001*ratio + 2534)*100)/100;
    }
}

function parseTime(value){
    if(!value) return 0;
    value = String(value).trim();
    const parts = value.split(':');
    if(parts.length === 2){
        const min = parseInt(parts[0]) || 0;
        const sec = parseFloat(parts[1].replace(',', '.')) || 0;
        return min*60 + sec;
    }
    return parseFloat(value.replace(',', '.')) || 0;
}

function formatTime(seconds) {
    if (!seconds || isNaN(seconds)) return '';
    const min = Math.floor(seconds / 60);
    const sec = seconds % 60;
    // Sekunden mit führender Null, zwei Nachkommastellen, Komma als Dezimaltrennzeichen
    const secStr = sec.toFixed(2).padStart(5, '0').replace('.', ',');
    return `${min}:${secStr}`;
}


function mergeBestTimesAfterCutoff(rows, headers, cutoffDate) {
    const nameMap = new Map();

    rows.forEach(row => {
        const name = row['Name'] || row['name'];
        const excelDate = row[headers[9]];
        let birthYear = row[headers[11]]; // Spalte L

        // Wenn Name fehlt, Datum fehlt, Datum vor Cutoff oder Jahrgang >= 10 → überspringen
        if (!name || !excelDate || ((typeof excelDate === 'number' ? new Date((excelDate - 25569) * 86400 * 1000) : new Date(excelDate)) <= cutoffDate) || !birthYear || parseInt(birthYear, 10) >= 10) {
            return; 
        }

        // Hier geht es weiter: Name, Datum und Jahrgang passen
        let rowDate = typeof excelDate === 'number' ? new Date((excelDate - 25569) * 86400 * 1000) : new Date(excelDate);
        birthYear = parseInt(birthYear, 10);

        if (!nameMap.has(name)) {
            const entry = { ...row };
            for (let j = 2; j < 9; j++) {
                const col = headers[j];
                entry[col + '_wk'] = row['Wettkampf'] || '';
            }
            nameMap.set(name, entry);
        } else {
            const existing = nameMap.get(name);
            for (let j = 2; j < 9; j++) {
                const col = headers[j];
                const oldTime = parseTime(existing[col]);
                const newTime = parseTime(row[col]);
                if (newTime > 0 && (oldTime === 0 || newTime < oldTime)) {
                    existing[col] = row[col];
                    existing[col + '_wk'] = row['Wettkampf'] || '';
                }
            }
            nameMap.set(name, existing);
        }
    });

    return Array.from(nameMap.values());
}

function renderTable(containerId, data, page) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';

    const start = page * PAGE_SIZE;
    const pageRows = data.slice(start, start + PAGE_SIZE);

    // Scroll-Container erstellen
    const scrollDiv = document.createElement('div');
	scrollDiv.classList.add('table-container');
	scrollDiv.style.overflowX = 'auto';
	scrollDiv.style.width = '100%';


    const table = document.createElement('table');

	// --- NEU: Colgroup für Spaltenbreiten ---
	const colgroup = document.createElement('colgroup');
	const colWidths = [120, 55, 100, 100, 100, 100, 100, 100]; // Breiten für Handy
	colWidths.forEach(width => {
	    const col = document.createElement('col');
	    col.style.width = width + 'px';
	    colgroup.appendChild(col);
	});
	table.appendChild(colgroup); // Muss vor thead kommen


    // --- THEAD ---
    const thead = document.createElement('thead');
    const trHeader = document.createElement('tr');

    const visibleHeaders = [headers[1], ...headers.slice(2, headers.length - 3)];

    visibleHeaders.forEach((h, index) => {
        const th = document.createElement('th');

        // Header-Inhalt
        if (h.toLowerCase() === 'punkte' || h === headers[1]) {
            th.textContent = h;
        } else {
            const gender = containerId === 'female-table' ? 'w' : 'm';
            const disciplineKey = h.trim();
            const wr = records[gender][disciplineKey] || 0;
            th.innerHTML =
                h +
                (wr
                    ? '<br><small style="font-size:0.8em; display:block; line-height:1.2; margin:0; padding:0; font-weight:normal;">' +
                      formatTime(wr) +
                      '</small>'
                    : '');
        }

        // **WICHTIG**: keine Inline-Breiten mehr setzen
        th.style.textAlign = 'center';
        if (h === headers[1]) th.style.textAlign = 'left';
        trHeader.appendChild(th);
    });

    thead.appendChild(trHeader);
    table.appendChild(thead);

    // --- TBODY ---
    const tbody = document.createElement('tbody');
    pageRows.forEach((row, idx) => {
        const tr = document.createElement('tr');

        const globalIndex = start + idx;
        if (globalIndex < 6) {
            if (containerId === 'male-table') tr.style.backgroundColor = 'rgba(173, 216, 230, 0.4)';
            else if (containerId === 'female-table') tr.style.backgroundColor = 'rgba(255, 182, 193, 0.4)';
        }

        visibleHeaders.forEach(h => {
            const td = document.createElement('td');

            if (h.toLowerCase() === 'punkte') {
                td.textContent = row['Punkte'];
            } else if (h.toLowerCase() === 'name') {
                const name = row[headers[1]] || '';
                let year = row[headers[11]];
                if (year !== undefined && year !== '') {
                    year = parseInt(year, 10);
                    const yearStr = String(year).padStart(2, '0');
                    td.textContent = `${name} - ${yearStr}`;
                } else {
                    td.textContent = name;
                }
            } else {
                const t = parseTime(row[h]);
                const wk = row[h + '_wk'] || '';
                td.innerHTML = t
                    ? `${formatTime(t)}<br><small style="font-size:0.7em; display:block; line-height:1; margin:0; padding:0;">${wk}</small>`
                    : '';
            }

            td.style.textAlign = h === headers[1] ? 'left' : 'center';

            // Abgesagte anzeigen
            if (h.toLowerCase() === 'punkte') {
                if (isCanceled(row['Name'])) {
                    td.textContent = 'Abgesagt';
                    td.style.color = 'rgb(227,6,19)';
                } else {
                    td.style.color = '';
                }
            }

            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    scrollDiv.appendChild(table);
    container.appendChild(scrollDiv);

    // Filter: mindestens 3 Disziplinen
    let rowsArr = Array.from(tbody.querySelectorAll('tr'));
    rowsArr.forEach(tr => {
        const cells = Array.from(tr.querySelectorAll('td')).slice(2);
        const validCount = cells.reduce((count, td) => td.textContent.trim() !== '' ? count + 1 : count, 0);
        if (validCount < 3) tr.remove();
    });
}






// Navigation Buttons
function setupButtons(){
    document.getElementById('male-prev').onclick = ()=>{
        if(malePage>0) malePage--;
        renderTable('male-table', maleData, malePage);
    };
    document.getElementById('male-next').onclick = ()=>{
        if((malePage+1)*PAGE_SIZE < maleData.length) malePage++;
        renderTable('male-table', maleData, malePage);
    };
    document.getElementById('female-prev').onclick = ()=>{
        if(femalePage>0) femalePage--;
        renderTable('female-table', femaleData, femalePage);
    };
    document.getElementById('female-next').onclick = ()=>{
        if((femalePage+1)*PAGE_SIZE < femaleData.length) femalePage++;
        renderTable('female-table', femaleData, femalePage);
    };
}



async function loadRecords() {
    try {
        const resp = await fetch(RECORDS_URL);
        const ab = await resp.arrayBuffer();
        const wb = XLSX.read(ab, { type: 'array' });
        const sheet = wb.Sheets[wb.SheetNames[0]];

        const records = { m: {}, w: {} };
        const data = XLSX.utils.sheet_to_json(sheet, { defval: '' });

        data.forEach(row => {
            const parts = row['Gender - Disziplin'].trim().split(' - '); // trennt "m" und "100m Lifesaver"
const gender = parts[0].trim();  // "m" oder "w"
const discipline = parts[1].trim(); // "100m Lifesaver"
const seconds = parseTime(row['World Record']);
const personName = row[headers[1]];

if (gender && discipline) {
    records[gender][discipline] = seconds;
}

        });

        return records;
    } catch (e) {
        console.error(e);
        return { m: {}, w: {} };
    }
}
async function loadAndShow() {
    try {
        const resp = await fetch(EXCEL_URL);
        const ab = await resp.arrayBuffer();
        const wb = XLSX.read(ab, { type: 'array' });
        const sheet = wb.Sheets[wb.SheetNames[0]];

        let json = XLSX.utils.sheet_to_json(sheet, { defval: '' });
        headers = Object.keys(json[0] || {});

        // --- Map nur mit Zeiten nach Cutoff erstellen ---
        const nameMap = new Map();

        json.forEach(row => {
            const excelDate = row[headers[9]];
            if (!excelDate) return;

            let rowDate;
            if (typeof excelDate === 'number') {
                rowDate = new Date((excelDate - 25569) * 86400 * 1000);
            } else {
                rowDate = new Date(excelDate);
            }

            // Nur Personen nach Cutoff berücksichtigen
            if (rowDate <= cutoffDate) return;

            const name = row['Name'];
            if (!name) return;

            if (!nameMap.has(name)) {
                const entry = { ...row };
                for (let j = 2; j <= 8; j++) {
                    const col = headers[j];
                    entry[col + '_wk'] = row['Wettkampf'] || '';
                }
                nameMap.set(name, entry);
            } else {
                // Merge-Zeiten bei doppeltem Eintrag
                const existing = nameMap.get(name);
                for (let j = 2; j <= 8; j++) {
                    const col = headers[j];
                    const oldTime = parseTime(existing[col]);
                    const newTime = parseTime(row[col]);
                    if (newTime > 0 && (oldTime === 0 || newTime < oldTime)) {
                        existing[col] = row[col];
                        existing[col + '_wk'] = row['Wettkampf'] || '';
                    }
                }
                nameMap.set(name, existing);
            }
        });

        // --- Array aus der Map erstellen ---
        let allData = Array.from(nameMap.values());

        // --- Punkteberechnung nur für Zeiten nach Cutoff ---
        allData.forEach(r => {
            const pointsArr = [];
            for (let j = 2; j <= 8; j++) {
                const col = headers[j];
                const time = parseTime(r[col]);
                if (!time) continue;

                const gender = r['Gender'].toLowerCase() === 'w' ? 'w' : 'm';
                const recordVal = records[gender][col] || 40;
                const points = new CalculatorDiscipline(time, recordVal).getPoints();
                pointsArr.push(points);
            }

            // Top 4 Punkte summieren
            pointsArr.sort((a, b) => b - a);
            r['Punkte'] = Math.round(pointsArr.slice(0, 4).reduce((a, b) => a + b, 0) * 100) / 100;
        });

        // --- Daten nach Geschlecht filtern ---
        maleData = allData.filter(r => !r['Gender'].toLowerCase().startsWith('w'));
        femaleData = allData.filter(r => r['Gender'].toLowerCase().startsWith('w'));

        // --- Sortieren nach Punkten ---
        maleData.sort((a, b) => b['Punkte'] - a['Punkte']);
        femaleData.sort((a, b) => b['Punkte'] - a['Punkte']);

        renderTable('male-table', maleData, malePage);
        renderTable('female-table', femaleData, femalePage);
        setupButtons();
	
	// --- Sortieren nach Punkten, abgesagte nach hinten ---
maleData.sort((a, b) => {
    const aCanceled = isCanceled(a['Name']);
    const bCanceled = isCanceled(b['Name']);

    if (aCanceled && !bCanceled) return 1;   // a nach hinten
    if (!aCanceled && bCanceled) return -1;  // b nach hinten
    if (aCanceled && bCanceled) return 0;    // beide abgesagt → gleich

    return (b['Punkte'] || 0) - (a['Punkte'] || 0);
});

femaleData.sort((a, b) => {
    const aCanceled = isCanceled(a['Name']);
    const bCanceled = isCanceled(b['Name']);

    if (aCanceled && !bCanceled) return 1;
    if (!aCanceled && bCanceled) return -1;
    if (aCanceled && bCanceled) return 0;

    return (b['Punkte'] || 0) - (a['Punkte'] || 0);
});

function sortAfterCleanup(data) {
    // Abgesagte ans Ende
    data.sort((a, b) => {
        const aCanceled = isCanceled(a['Name']);
        const bCanceled = isCanceled(b['Name']);
        if (aCanceled && !bCanceled) return 1;
        if (!aCanceled && bCanceled) return -1;

        // Danach nach Punkten sortieren
        return (b['Punkte'] || 0) - (a['Punkte'] || 0);
    });
}

// Beispiel:
sortAfterCleanup(maleData);
sortAfterCleanup(femaleData);

// --- Danach erst Tabellen rendern ---
renderTable('male-table', maleData, malePage);
renderTable('female-table', femaleData, femalePage);
setupButtons();

	
    } catch (e) {
        console.error(e);
    }
}

async function init(){
    records = await loadRecords();
    await loadAndShow();
}

init();
</script>
</body>
</html>




















